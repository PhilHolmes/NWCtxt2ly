using System;
using System.Collections;
using System.Collections.Generic;
using System.Windows.Forms;
using System.IO;
using System.Text;

// Todo:
// Check whether LastKey has any function at all - (taken out and no difference)
// Full bar rests - done
// Chords with different note durations - done
// Restchords - done
// Endings - done
// Bug with beams from Hallelujah upper manual - flags this as illegal music and does its best
// Check for valid RestChords?
// Tenuto - done
// Slurs with RestChords where the slur continues past the end of the restchord.

namespace nwc2ly
{
	public class nwc2ly
	{
		public static char[] Key = new char[7];
		public static char[] BarKey = new char[7];
		public static string Output = "";
		public static int CrescEndPos = 0;
		public static string Last = "";
		public static string Line = "";
		public static string Cmd = "";
		public static string Note = "";
		public static string s1 = "";
		public static string s2 = "";
		public static string s3 = "";
		public static string s4 = "";
		public static string s5 = "";
		public static string CurClef = "";
		public static int FromC = 0;
		public static int i = 0;
		public static int j = 0;
		public static int N = 0;
		public static int Code = 0;
		public static bool Slur = false;
		public static bool Tied = false;
		public static bool Grace = false;
		public static string Dyn = "";
		public static string Chord = "";
		public static int LastCresc = 0;
		public static char c = (char)0;
		public static int BarNo = 0;
		public static bool Fermata = false;
		public static string NextText = "";
		public static string CrescLocation = "";
		public static string AddedText = "";
		public static bool bBarWritten = false;
		public static int ClearTextDynamicVariance = 0;
		public static string TimeSig = "";
		private static bool bInEnding = false;
		private static bool bFinalEnding = false;
		private static bool InBeam = false;

		[STAThread]
		public static void Main(string[] args)
		{
			CrescEndPos = -1;
			Output = "";
			NextText = "";

#if DEBUG
			StreamWriter OutFile;
			Console.SetIn(new StreamReader("D:\\Noteworthy.txt"));
#endif

			string Input;
			List<string> InputList = new List<string>();
			try
			{
				Input = Console.In.ReadLine();
				InputList.Add(Input);
			}
			catch (Exception)
			{
				MessageBox.Show("No input stream", "NWC2LY");
				Console.WriteLine("No input stream", "NWC2LY");
				Environment.Exit(99);
				return;
			}

			while (Console.In.Peek() >= 0)
			{
				Input = Console.In.ReadLine();
				if (Input.IndexOf("Dur2") >= 0)
				{
					ParseMultiChord(Input, InputList);
				}
				else
				{
					InputList.Add(Input);
				}
			} 

			string ver = Application.ProductVersion;
			WriteLn("% Generated by nwc2ly C# version " + ver + " by Phil Holmes");
			WriteLn("% Based on nwc2ly by Mike Wiering");
			WriteLn("");

			Line = InputList[0];
			InputList.RemoveAt(0);

			if (Line != "!NoteWorthyComposerClip(2.0,Single)")
			{
				WriteLn("*** Unknown format ***");
#if DEBUG
				OutFile = new StreamWriter("D:\\Music\\Noteworthy.ly", false);
				Console.SetOut(OutFile);
#endif
				Console.Out.Write(Output);
#if DEBUG
				OutFile.Close();
#endif
				Environment.Exit(99);
				return;
			}


			WriteLn("\\version \"2.8.0\"");
			WriteLn("\\pointAndClickOff");
			WriteLn("\\header {");
			WriteLn("  title = \"Title\"");
			WriteLn("  subtitle = \"Subtitle\"");
			// WriteLn ('  subsubtitle = "Subsubtitle"');
			// WriteLn ('  dedication = "Dedication"');
			WriteLn("  composer = \"Composer\"");
			WriteLn("  instrument = \"Instrument\"");
			// WriteLn ('  arranger = "Arranger"');
			// WriteLn ('  poet = "Poet"');
			// WriteLn ('  texttranslator = "Translator"');
			WriteLn("  copyright = \"Copyright\"");
			// WriteLn ('  source = "source"');
			// WriteLn ('  enteredby = "entered by"');
			// WriteLn ('  maintainerEmail = "email"');
			// WriteLn ('  texidoc = "texidoc"');
			WriteLn("  piece = \"Piece\"");
			// WriteLn ('  opus = "Opus 0"');
			WriteLn("}");
			WriteLn("");
			WriteLn("\\score {");
			WriteLn("{");
			WriteLn(" #(set-accidental-style 'modern-cautionary)");
			CurClef = "treble";
			SetKeySig("");
			Slur = false;
			Tied = false;
			Grace = false;
			Dyn = "";
			LastCresc = 0;
			ClearBarKeys();
			BarNo = 1;
			Fermata = false;

			Line = InputList[0];
			InputList.RemoveAt(0);
			do
			{
				if (Line == "")
				{
				}
				bBarWritten = false;
				Last = Line;
				Cmd = GetCommand(ref Line);
				if (!((Line.IndexOf("Visibility:Never") >= 0) && ("NoteChordRest".IndexOf(Cmd) < 0)))
				{
					if (Cmd == "Voicestart")
					{
						if (InBeam)
						{
							WriteLn("  % Prematurely ending beam which spans voices.  To correct this, use layering in Noteworthy");
							Write("]");
							InBeam = false;
						}
						WriteLn("<<");
						WriteLn("{");
					}
					else if (Cmd == "Voicebreak")
					{
						if (InBeam)
						{
							WriteLn("  % Prematurely ending beam which spans voices.  To correct this, use layering in Noteworthy");
							Write("]");
							InBeam = false;
						}
						WriteLn(@"}\\");
						WriteLn("{");
					}
					else if (Cmd == "Voiceend")
					{
						if (InBeam)
						{
							WriteLn("% Prematurely ending beam which spans voices.  To correct this, use layering in Noteworthy");
							Write("]");
							InBeam = false;
						}
						WriteLn("}");
						WriteLn(">>");
					}
					else if (Cmd == "Ending")
					{
						s1 = GetPar("Endings", Line, true);
						if (bInEnding)
						{
							WriteLn("\\set Score.repeatCommands = #'((volta #f)(volta \"" + s1 + "\"))");
							bFinalEnding = true;
							bInEnding = false;
						}
						else
						{
							WriteLn("\\set Score.repeatCommands = #'((volta \"" + s1 + "\"))");
						}
						bInEnding = true;
					}
					else if (Cmd == "Clef")
					{
						s1 = GetPar("Type", Line).ToLower();
						s2 = GetPar("OctaveShift", Line);
						CurClef = s1;
						if (s2 == "Octave Up")
						{
							s1 = s1 + "^8";
						}
						if (s2 == "Octave Down")
						{
							s1 = s1 + "_8";
						}
						WriteLn(" \\clef " + s1);
						Last = "";
					}
					else if (Cmd == "Key")
					{
						s1 = GetPar("Signature", Line, true);
						s1 = SetKeySig(s1);
						WriteLn(" \\key " + s1);
						Last = "";
						ClearBarKeys();
					}
					else if (Cmd == "Dynamic")
					{
						Dyn = "";
						if (Math.Abs(LastCresc) != 0)
						{
							Dyn = "\\! ";
							LastCresc = 0;
						}
						Dyn = Dyn + '\\' + GetPar("Style", Line, true);
						Last = "";
					}
					else if (Cmd == "TimeSig")
					{
						s1 = GetPar("Signature", Line);
						if (s1 == "Common")
						{
							s1 = "4/4";
						}
						if (s1 == "AllaBreve")
						{
							s1 = "2/2";
						}
						WriteLn(" \\time " + s1);
						TimeSig = s1;
						Last = "";
					}
					else if ((Cmd == "Note") || (Cmd == "Chord"))
					{
						WriteNotes();
					}
					else if (Cmd == "Rest")
					{
						WriteRests();
					}
					else if (Cmd == "RestChord")
					{
						WriteLn(" % Incorrectly parsed restchord: notes from chord have not been added");
						WriteRests();
					}
					else if (Cmd == "DynamicVariance")
					{
						s1 = GetPar("Style", Line);
						CrescLocation = GetPosChar(Line);
						if (s1 == "Crescendo")
						{
							Write("\\crescTextCresc ");
							LastCresc = 3;
						}
						if (s1 == "Decrescendo")
						{
							Write("\\dimTextDecresc ");
							LastCresc = -3;
						}
						if (s1 == "Diminuendo")
						{
							Write("\\dimTextDim ");
							LastCresc = -3;
						}
						Last = "";
					}
					else if (Cmd == "Tempo")
					{
						s1 = GetPar("Base", Line);
						if (s1 == "Half")
						{
							s1 = "2";
						}
						if (s1 == "Half Dotted")
						{
							s1 = "2.";
						}
						if (s1 == "Quarter")
						{
							s1 = "4";
						}
						if (s1 == "Quarter Dotted")
						{
							s1 = "4.";
						}
						if (s1 == "Eighth")
						{
							s1 = "8";
						}
						if (s1 == "Eighth Dotted")
						{
							s1 = "8.";
						}
						if (s1 == "")
						{
							s1 = "4";
						}
						WriteLn(" \\tempo " + s1 + '=' + GetPar("Tempo", Line));
						Last = "";
					}
					else if (Cmd == "TempoVariance")
					{
						s1 = GetPar("Style", Line);
						if (s1 == "Fermata")
						{
							Fermata = true;
						}
						else if (s1 == "Breath Mark")
						{
							Write(" \\breathe ");
						}
						else
						{
							NextText = "^\\markup{\\italic{ " + s1 + " }}" + NextText;
						}
						Last = "";
					}
					else if (Cmd == "Text")
					{
						s1 = GetPar("Text", Line);
						if (s1.Length > 0)
						{
							s1 = s1.Replace("\"", "");
							string Location = GetPosChar(Line);
							AddedText += Location + "\\markup {\\small \\italic \"" + s1 + "\"}";
						}
						else
						{
							WriteLn("% Unparsed text expression: " + Last);
						}
					}
					else if (Cmd == "PerformanceStyle")
					{
						s1 = GetPar("Style", Line);
						string Location = GetPosChar(Line);
						AddedText += Location + "\\markup {\\small \\italic \"" + s1 + "\"}";
					}

					else if (Cmd == "SustainPedal")
					{
						s1 = GetPar("Status", Line);
						string Location = GetPosChar(Line);
						if (s1 == "")
						{
							AddedText += Location + "\\sustainOn";
						}
						else
						{
							AddedText += Location + "\\sustainOff";
						}
					}
					else if (Cmd == "Bar")
					{
						WriteBars();
						ClearBarKeys();
					}
					else
					{
						WriteLn("% Unparsed command: " + Last);
					}
				}
				Line = InputList[0];
				InputList.RemoveAt(0);
			} while (InputList.Count > 0);
			CheckCresc();
			if (!bBarWritten)
			{
				WriteLn(" \\bar \"|.\"");
			}
			WriteLn(" }");
			WriteLn("}");
#if DEBUG
			OutFile = new StreamWriter("D:\\Music\\Noteworthy.ly", false);
			Console.SetOut(OutFile);
#endif
			Console.Out.Write(Output);
#if DEBUG
			OutFile.Close();
#endif
			Environment.Exit(99);
			Application.Run();
		}

		public static void Write(string Txt)
		{
			Output = Output + Txt;
		}

		public static void WriteLn(string Txt)
		{
			Write(Txt + "\r\n");
		}

		public static string SetKeySig(string s)
		{
			string result;
			int c;
			int Sharps;
			int Flats;
			for (c = 0; c < 7; c++)
			{
				Key[c] = 'n';
			}
			Sharps = 0;
			Flats = 0;
			while (s.Length > 1)
			{
				c = (char)((int)s[0] - 'A');
				Key[c] = s[1];
				if (s[1] == '#')
				{
					Sharps++;
				}
				if (s[1] == 'b')
				{
					Flats++;
				}
				if (s.Length > 2)
				{
					s = s.Remove(0, 3);
				}
				else
				{
					s = "";
				}
			}
			switch (Sharps - Flats)
			{
				case -7:
					s = "as\\minor";
					break;
				case -6:
					s = "es\\minor";
					break;
				case -5:
					s = "bes\\minor";
					break;
				case -4:
					s = "f\\minor";
					break;
				case -3:
					s = "c\\minor";
					break;
				case -2:
					s = "g\\minor";
					break;
				case -1:
					s = "d\\minor";
					break;
				case 0:
					s = "c\\major";
					break;
				case 1:
					s = "g\\major";
					break;
				case 2:
					s = "d\\major";
					break;
				case 3:
					s = "a\\major";
					break;
				case 4:
					s = "e\\major";
					break;
				case 5:
					s = "b\\major";
					break;
				case 6:
					s = "fis\\major";
					break;
				case 7:
					s = "cis\\major";
					break;
			}
			result = s;
			return result;
		}

		public static string GetCommand(ref string Line)
		{
			string result;
			string s;
			s = "";
			if (Line == null || Line =="")
			{
			}
			else if (Line[0] == '|')
			{
				Line = Line.Remove(0, 1);
				do
				{
					s = s + Line[0];
					Line = Line.Remove(0, 1);
				} while (!((Line == "") || (Line[0] == '|')));
			}
			result = s;
			return result;
		}

		public static string GetPar(string ParName, string Line, bool All)
		{
			string result;
			int i;
			string s;
			string Stop;
			if (All)
			{
				Stop = "|";
			}
			else
			{
				Stop = "|,";
			}
			s = "";
			i = Line.IndexOf(ParName + ':');
			if (i > 0)
			{
				i = i + 1 + ParName.Length;
				while ((i < Line.Length) && (!(Stop.IndexOf(Line[i]) >= 0)))
				{
					s = s + Line[i];
					i = i + 1;
				}
			}
			result = s;
			return result;
		}

		public static string GetPar(string ParName, string Line)
		{
			return GetPar(ParName, Line, false);
		}

		public static int GetVal(string s)
		{
			int result;
			int i;
			int j;
			Val(s, out i, out j);
			if (j != 0)
			{
				i = 0;
			}
			result = i;
			return result;
		}

		public static void Val(string NumberString, out int Number, out int Error)
		{
			Error = 0;
			Number = 0;
			try
			{
				Number = int.Parse(NumberString);
			}
			catch (Exception)
			{
				Error = 1;
			}
		}

		public static void CheckCresc()
		{
			bool bCresc;
			bool bDeCresc;
			bCresc = GetPar("Opts", Line, true).IndexOf("Crescendo") >= 0;
			bDeCresc = GetPar("Opts", Line, true).IndexOf("Diminuendo") >= 0;
			if (Math.Abs(LastCresc) == 1)
			{ // We need to check whether the crescendo needs "closing"
				if (!(bCresc || bDeCresc))
				{  // We are not in a cres/dec so yes, we do
					if (CrescEndPos != -1)
					{
						Output = Output.Insert(CrescEndPos - 1, "\\! ");  // Write the end code into the middle of the line ...
						CrescEndPos = -1;
					}
					else
					{
						Write("\\! "); // Check how we get here...
					}
					LastCresc = 0;
				}
				else
				{
					CrescEndPos = Output.Length + 1;
				}
			}
			switch (LastCresc)
			{  // This handles text dynamic variance.
				case 3:
					Write(CrescLocation + "\\< ");
					LastCresc = 2;
					break;
				case 2:
					Write("\\! ");
					ClearTextDynamicVariance = 1;
					LastCresc = 0;
					break;
				case -3:
					Write(CrescLocation + "\\> ");
					LastCresc = -2;
					break;
				case -2:
					Write("\\! ");
					ClearTextDynamicVariance = -1;
					LastCresc = 0;
					break;
			}
			if (bCresc)
			{
				if (LastCresc != 1)
				{
					if (LastCresc == -1)
					{
						Write("\\! ");
					}
					Write(CrescLocation + "\\< ");
					LastCresc = 1;
					CrescEndPos = -1;
				}
			}
			if (bDeCresc)
			{
				if (LastCresc != -1)
				{
					if (LastCresc == 1)
					{
						Write("\\! ");
					}
					Write(CrescLocation + "\\> ");
					LastCresc = -1;
					CrescEndPos = -1;
				}
			}
		}

		private static string GetPosChar(string Input)
		{
			string Location = GetPar("Pos", Line);
			int Position = 0;
			try
			{
				Position = int.Parse(Location);
			}
			catch (Exception) { }
			Location = "_";
			if (Position > 0)
			{
				Location = "^";
			}

			return Location;
		}

		private static void WriteBars()
		{
			bBarWritten = true;

			if (ClearTextDynamicVariance != 0)
			{
				if (ClearTextDynamicVariance == 1)
				{
					Write(" \\crescHairpin ");
				}
				else
				{
					Write(" \\dimHairpin ");
				}
				ClearTextDynamicVariance = 0;
			}

			if (bFinalEnding)
			{
				WriteLn("\\set Score.repeatCommands = #'((volta #f))");
				bFinalEnding = false;
			}

			s1 = GetPar("Style", Line);
			if (s1 == "Double")
			{
				Write("  \\bar \"||\"  % ");
			}
			else if (s1 == "MasterRepeatOpen")
			{
				Write("  \\bar \"|:\"  % ");
			}
			else if (s1 == "MasterRepeatClose")
			{
				Write("  \\bar \":|\"  % ");
			}
			else if (s1 == "LocalRepeatOpen")
			{
				Write("  \\bar \"|:\"  % ");
			}
			else if (s1 == "LocalRepeatClose")
			{
				s2 = GetPar("Repeat", Line);
				int Repeats = 0;
				try
				{
					Repeats = int.Parse(s2);
				}
				catch (Exception) { }
				if (Repeats > 2)
				{
					Write("_\\markup {\\small \\italic \"(" + Repeats.ToString() + " times)\"}");
				}
				Write("  \\bar \":|\"  % ");
			}
			else if (s1 == "SectionOpen")
			{
				Write("  \\bar \".|\"  % ");
			}
			else if (s1 == "SectionClose")
			{
				Write("  \\bar \"|.\"  % ");
			}
			else if (s1 == "")
			{
				Write("  |  % ");
			}
			else
			{
				Write("  |  % " + " unknown bar type " + s1);
			}
			WriteLn(BarNo.ToString());
			BarNo++;
		}

		private static void WriteNotes()
		{
			string Octave = "";
			int OctaveIndicator = 0;

			s3 = GetPar("Dur", Line);
			s4 = "";
			s3 = GetDur(s3);

			if (Line.IndexOf("Visibility:Never") >= 0)
			{
				if (Line.IndexOf("Grace") < 0)
				{
					Write("s" + s3);  // This ensures that hidden notes still have a time value
				}
			}
			else
			{
				if (Line.IndexOf("Triplet=First") >= 0)
				{
					Write("\\times 2/3 { ");
				}
				if (Grace)
				{
					if (Line.IndexOf("Grace") < 0)
					{
						Write(" } ");
						Grace = false;
					}
				}
				else if (Line.IndexOf("Grace") >= 0)
				{
					Write(" \\appoggiatura { ");
					Grace = true;
				}

				FromC = 0;
				if (CurClef.ToLower() == "treble")
				{
					FromC = 6;
				}
				else if (CurClef.ToLower() == "bass")
				{
					FromC = -6;
				}
				else if (CurClef.ToLower() == "alto")
				{
					FromC = 0;
				}
				else if (CurClef.ToLower() == "tenor")
				{
					FromC = 2;
				}
				Chord = GetPar("Pos", Line, true);
				if (Cmd == "Chord")
				{
					Write("<");
				}
				do
				{
					s1 = "";
					do
					{
						s1 = s1 + Chord[0];
						Chord = Chord.Remove(0, 1);
					} while (!((Chord == "") || (Chord[0] == ',')));
					if ((Chord != ""))
					{
						if ((Chord[0] == ','))
						{
							Chord = Chord.Remove(0, 1);
						}
					}
					if (s1[s1.Length - 1] == '^')
					{
						Tied = true;
						s1 = s1.Remove(s1.Length - 1, 1);
					}
					s5 = "";
					if (s1[0] == '+')
					{
						s1 = s1.Remove(0, 1);
					}
					if ("#nbxv".IndexOf(s1[0]) >= 0) // Checks whether the note has an accidental
					{
						s5 = s1[0].ToString();
						s1 = s1.Remove(0, 1);
					}
					Val(s1, out N, out Code);
					N = N + FromC;
					Note = ((char)('a' + ((N + 2 + 70) % 7))).ToString();
					OctaveIndicator = (70 + N) / 7 - 10;
					if (OctaveIndicator < -1)
					{
						Octave = new string(',', Math.Abs(OctaveIndicator) - 1);
					}
					else
					{
						Octave = new string('\'', OctaveIndicator + 1);
					}

					if (s5 == "")
					{
						s5 = BarKey[Note[0] - 'a'].ToString();
					}
					if (s5 == "\0")
					{
						s5 = Key[Note[0] - 'a'].ToString();
					}
					if (s5 == "#")
					{
						Note = Note + "is";
					}
					if (s5 == "x")
					{
						Note = Note + "isis";
					}
					if (s5 == "b")
					{
						Note = Note + "es";
					}
					if (s5 == "v")
					{
						Note = Note + "eses";
					}
					if ((Note.Length > 1) || (s5 == "n"))
					{
						BarKey[Note[0] - 'a'] = s5[0];
					}
					Write(' ' + Note + Octave);
				} while (!(Chord == ""));
				if (Cmd == "Chord")
				{
					Write(">");
				}
				Write(s3); // duration
				if (Line.IndexOf("Staccato") >= 0)
				{
					Write("-.");
				}
				if (Line.IndexOf("Accent") >= 0)
				{
					Write("->");
				}
				if (Line.IndexOf("Tenuto") >= 0)
				{
					Write("--");
				}
				if (NextText != "")
				{
					Write(NextText);
					NextText = "";
				}
				if (Fermata)
				{
					Write("\\fermata ");
					Fermata = false;
				}
				if (Dyn != "")
				{
					Write(Dyn + ' ');
					Dyn = "";
				}
				if (AddedText != "")
				{
					Write(AddedText + ' ');
					AddedText = "";
				}
				if (Tied)
				{
					Write(" ~ ");
					Tied = false;
				}
				if (Line.IndexOf("Slur") >= 0)
				{
					if (Slur == false)
					{
						Write(" ( ");
						Slur = true;
					}
				}
				if (Slur)
				{
					if (Line.IndexOf("Slur") < 0)
					{
						Write(" ) ");
						Slur = false;
					}
				}
				CheckCresc();
				if (Line.IndexOf("Beam=First") > 0)
				{
					Write(" [ ");
					InBeam = true;
				}
				if (Line.IndexOf("Beam=End") > 0 && InBeam)
				{
					Write(" ] ");
				}
				if (Line.IndexOf("Triplet=End") > 0)
				{
					Write(" } ");
				}
				Last = "";
			}
		}
		private static void WriteRests()
		{
			s1 = GetPar("Dur", Line);
			s2 = "";
			s1 = GetDur(s1);

			if (Line.IndexOf("Visibility:Never") >= 0)
			{
				Write("s" + s1 + " ");  // This ensures that hidden rests still have a time value
			}
			else
			{
				if (Line.IndexOf("Whole") >= 0)
				{
					Write(" R1*" + TimeSig + " ");

				}
				else
				{
					Write(" r" + s1 + " ");
				}
			}
			if (Fermata)
			{
				Write("\\fermata ");
				Fermata = false;
			}
			CheckCresc();
			Last = "";
		}
		private static string GetDur(string Dur)
		{
			return GetDur(Dur, false);
		}
		private static string GetDur(string Dur, bool ReturnNumberOnly)
		{
			if (Dur == "Whole")
			{
				Dur = "1";
			}
			if (Dur == "Half")
			{
				Dur = "2";
			}
			Dur = Dur.Replace("st", "");
			Dur = Dur.Replace("nd", "");
			Dur = Dur.Replace("rd", "");
			Dur = Dur.Replace("th", "");
			if (Line.IndexOf("DblDotted") >= 0)
			{
				Dur += "..";
			}
			else if (Line.IndexOf("Dotted") >= 0)
			{
				Dur += ".";
			}
			int CommaPos = Dur.IndexOf(",");
			if (CommaPos >= 0 && ReturnNumberOnly)
			{
				Dur = Dur.Substring(0, CommaPos);
			}

			return Dur;
		}
		private static void ClearBarKeys()
		{
			for (int LoopVar = 0; LoopVar < 7; LoopVar++)
			{
				BarKey[LoopVar] = '\0';
			}
		}
		private static NoteInfo GetNoteInfo(string NoteInput, string Command, string BlankOr2)
		{
			NoteInfo NoteResult = new NoteInfo();
			Decimal dMult = 1M;
			string RealDur;

			NoteResult.Duration = GetPar("Dur" + BlankOr2, NoteInput, true);
			if (NoteResult.Duration.IndexOf(",DblDotted") >= 0)
			{
				dMult = 1.75M;
				NoteResult.Duration = NoteResult.Duration.Replace(",DblDotted", "");
				NoteResult.Dots = ",DblDotted";
			}
			else if (NoteResult.Duration.IndexOf(",Dotted") >= 0)
			{
				dMult = 1.5M;
				NoteResult.Duration = NoteResult.Duration.Replace(",Dotted", "");
				NoteResult.Dots = ",Dotted";
			}
			NoteResult.Position = GetPar("Pos" + BlankOr2, NoteInput, true);
			RealDur = GetDur(NoteResult.Duration, true);
			NoteResult.dDur = (decimal)1 / int.Parse(RealDur);
			NoteResult.dDur *= dMult;
			if (BlankOr2 == "")
			{
				NoteResult.Opts = GetPar("Opts", NoteInput, true);
			}
			dMult = 1M;
			NoteResult.Command = Command;
			if (NoteResult.Command == "RestChord")
			{
				if (BlankOr2 == "")
				{
					NoteResult.Command = "Rest";
				}
				else
				{
					if (NoteResult.Position.IndexOf(",") >= 0)
					{
						NoteResult.Command = "Chord";
					}
					else
					{
						NoteResult.Command = "Note";
					}
				}
			}

			return NoteResult;

		}
		private static void ParseMultiChord(string Input, List<string> InputList)
		{
			Voice[] NWVoice = new Voice[2];
			NoteInfo[] Notes = new NoteInfo[2];
			Notes[0] = new NoteInfo();
			Notes[1] = new NoteInfo();
			NoteInfo NextNote;
			bool VoiceOneFirst = true;
			string DynVar = "";
//			Decimal dMult = 1;

			if (Input.IndexOf("otte") >= 0)
			{
			}

			string Command = GetCommand(ref Input);
			if (Input.IndexOf("Stem=") < 0)
			{
				InputList.Add("% Multi length chord or rest with no stem direction"); //Don't think this will occur
			}

			if (InputList[InputList.Count - 1].IndexOf("DynamicVariance") >= 0)
			{   // We need to remove the variance and move it until before the first note of the voice with the most notes (!)
				// and also ensure that the end is on the same voice, and that any reset to the style occurs on the same voice.
				DynVar = InputList[InputList.Count - 1];
				InputList.RemoveAt(InputList.Count - 1);
			}

			if (Input.IndexOf("Stem=Down") >= 0)
			{
				// The second Noteworthy "note" goes to voice 1
				VoiceOneFirst = false;
			}

			Notes[0] = GetNoteInfo(Input, Command, "");
			Notes[1] = GetNoteInfo(Input, Command, "2");

			NWVoice[0] = new Voice();
			NWVoice[1] = new Voice();

			if (VoiceOneFirst)
			{  // The first note read from Noteworthy goes to Voice One
				NWVoice[0].NoteList.Add(Notes[0].ToString());
				NWVoice[1].NoteList.Add(Notes[1].ToString());
			}
			else
			{
				NWVoice[0].NoteList.Add(Notes[1].ToString());
				NWVoice[1].NoteList.Add(Notes[0].ToString());
			}

			int ShorterDur;
			// The next bit is to work out which on the voices has the shorter duration and therefore needs more notes adding
			if (VoiceOneFirst)
			{
				if (Notes[0].dDur > Notes[1].dDur)
				{
					ShorterDur = 1;
				}
				else
				{
					ShorterDur = 0;
				}
			}
			else
			{
				if (Notes[0].dDur > Notes[1].dDur)
				{
					ShorterDur = 0;
				}
				else
				{
					ShorterDur = 1;
				}
			}

			decimal MinDur = Math.Min(Notes[0].dDur, Notes[1].dDur);
			decimal MaxDur = Math.Max(Notes[0].dDur, Notes[1].dDur);
			while (MinDur < MaxDur)
			{
				if (MinDur > MaxDur)
				{
				}
				Input = Console.In.ReadLine();
				string Cmd = GetCommand(ref Input);
				if (Cmd != "Note" && Cmd != "Chord" && Cmd != "Rest")
				{
					NWVoice[ShorterDur].NoteList.Add("|" + Cmd + "|" + Input);
				}
				else
				{
					NextNote = new NoteInfo();
					NextNote.Command = Cmd;
					NextNote.Position = GetPar("Pos", Input, true);
					NextNote.Duration = GetPar("Dur", Input, true);
					NextNote.dDur = (decimal)1 / int.Parse(GetDur(NextNote.Duration, true));
					NextNote.Opts = GetPar("Opts", Input, true);
					NWVoice[ShorterDur].NoteList.Add(NextNote.ToString());
					MinDur += NextNote.dDur;
				}
			}
			InputList.Add("|Voicestart");
			if (ShorterDur == 0 && DynVar.Length > 0)
			{
				InputList.Add(DynVar);
			}
			for (int i = 0; i < NWVoice[0].NoteList.Count; i++)
			{
				InputList.Add(NWVoice[0].NoteList[i]);
			}
			InputList.Add("|Voicebreak");
			if (ShorterDur == 1 && DynVar.Length > 0)
			{
				InputList.Add(DynVar);
			}
			for (int i = 0; i < NWVoice[1].NoteList.Count; i++)
			{
				InputList.Add(NWVoice[1].NoteList[i]);
			}
			InputList.Add("|Voiceend");
		}

	}
	public class NoteInfo
	{
		public string Duration;
		public string Position;
		public decimal dDur;
		public string Opts;
		public string Command;
		public string Dots = "";

		override public string ToString()
		{
			string Result = "|" + this.Command + "|Dur:" + this.Duration + "|Pos:" + this.Position + "|Opts:" + this.Opts + this.Dots;
			return Result;
		}
	}
	public class Voice
	{
		public List<string> NoteList = new List<string>();
	}


}

